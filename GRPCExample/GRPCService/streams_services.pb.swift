// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: streams_services.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum MultistreamType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownType // = 0
  case youtube // = 1
  case facebook // = 2
  case instagram // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownType
    case 1: self = .youtube
    case 2: self = .facebook
    case 3: self = .instagram
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownType: return 0
    case .youtube: return 1
    case .facebook: return 2
    case .instagram: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MultistreamType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MultistreamType] = [
    .unknownType,
    .youtube,
    .facebook,
    .instagram,
  ]
}

#endif  // swift(>=4.2)

public enum MultistreamStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownStatus // = 0
  case connected // = 1
  case disconnected // = 2
  case waiting // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownStatus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownStatus
    case 1: self = .connected
    case 2: self = .disconnected
    case 3: self = .waiting
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownStatus: return 0
    case .connected: return 1
    case .disconnected: return 2
    case .waiting: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MultistreamStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MultistreamStatus] = [
    .unknownStatus,
    .connected,
    .disconnected,
    .waiting,
  ]
}

#endif  // swift(>=4.2)

public enum FbChannelType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownChannel // = 0
  case profile // = 1
  case group // = 2
  case page // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownChannel
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownChannel
    case 1: self = .profile
    case 2: self = .group
    case 3: self = .page
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownChannel: return 0
    case .profile: return 1
    case .group: return 2
    case .page: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FbChannelType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FbChannelType] = [
    .unknownChannel,
    .profile,
    .group,
    .page,
  ]
}

#endif  // swift(>=4.2)

public struct GetStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var streamingURL: String = String()

  ///*
  /// Date and time when stream is planned to start
  public var plannedStart: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _plannedStart ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_plannedStart = newValue}
  }
  /// Returns true if `plannedStart` has been explicitly set.
  public var hasPlannedStart: Bool {return self._plannedStart != nil}
  /// Clears the value of `plannedStart`. Subsequent reads from it will return its default value.
  public mutating func clearPlannedStart() {self._plannedStart = nil}

  public var liveStatus: GetStreamResponse.LiveStatus {
    get {return _liveStatus ?? .undefined}
    set {_liveStatus = newValue}
  }
  /// Returns true if `liveStatus` has been explicitly set.
  public var hasLiveStatus: Bool {return self._liveStatus != nil}
  /// Clears the value of `liveStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLiveStatus() {self._liveStatus = nil}

  ///*
  /// Date and time when stream is actually started
  public var actualStart: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _actualStart ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_actualStart = newValue}
  }
  /// Returns true if `actualStart` has been explicitly set.
  public var hasActualStart: Bool {return self._actualStart != nil}
  /// Clears the value of `actualStart`. Subsequent reads from it will return its default value.
  public mutating func clearActualStart() {self._actualStart = nil}

  public var stats: StreamStats {
    get {return _stats ?? StreamStats()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  public var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  public mutating func clearStats() {self._stats = nil}

  ///*
  /// Date and time when stream was finished
  public var actualFinish: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _actualFinish ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_actualFinish = newValue}
  }
  /// Returns true if `actualFinish` has been explicitly set.
  public var hasActualFinish: Bool {return self._actualFinish != nil}
  /// Clears the value of `actualFinish`. Subsequent reads from it will return its default value.
  public mutating func clearActualFinish() {self._actualFinish = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum LiveStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case undefined // = 0
    case planned // = 1
    case active // = 2
    case finished // = 3
    case cancelled // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .undefined
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .planned
      case 2: self = .active
      case 3: self = .finished
      case 4: self = .cancelled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .planned: return 1
      case .active: return 2
      case .finished: return 3
      case .cancelled: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _plannedStart: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _liveStatus: GetStreamResponse.LiveStatus? = nil
  fileprivate var _actualStart: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _stats: StreamStats? = nil
  fileprivate var _actualFinish: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension GetStreamResponse.LiveStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [GetStreamResponse.LiveStatus] = [
    .undefined,
    .planned,
    .active,
    .finished,
    .cancelled,
  ]
}

#endif  // swift(>=4.2)

public struct GetAvailableMultistreamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var streamID: String = String()

  public var tokens: [GetAvailableMultistreamsRequest.TypeToken] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct TypeToken {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: MultistreamType = .unknownType

    public var token: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct GetAvailableMultistreamsRequestV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var streamID: String = String()

  public var tokens: [MultistreamTypeToToken] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetAvailableMultistreamsResponseV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var availableMultistreams: [MultistreamV2] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetAvailableMultistreamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var availableMultistreams: [Multistream] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SetMultistreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var streamID: String = String()

  public var type: MultistreamType = .unknownType

  public var title: String = String()

  public var description_p: String = String()

  public var category: String = String()

  public var privacy: String = String()

  public var connect: Bool = false

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SetMultistreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var multistream: Multistream {
    get {return _multistream ?? Multistream()}
    set {_multistream = newValue}
  }
  /// Returns true if `multistream` has been explicitly set.
  public var hasMultistream: Bool {return self._multistream != nil}
  /// Clears the value of `multistream`. Subsequent reads from it will return its default value.
  public mutating func clearMultistream() {self._multistream = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _multistream: Multistream? = nil
}

public struct Multistream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var streamID: String = String()

  public var type: MultistreamType = .unknownType

  public var title: String = String()

  public var description_p: String = String()

  public var category: String = String()

  public var availableCategories: [String] = []

  public var privacy: String = String()

  public var availablePrivacy: [String] = []

  public var status: MultistreamStatus = .unknownStatus

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SetMultistreamRequestV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var streamID: String = String()

  public var type: MultistreamType = .unknownType

  public var title: String = String()

  public var description_p: String = String()

  public var connect: Bool = false

  public var token: String = String()

  public var data: MultistreamData {
    get {return _data ?? MultistreamData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: MultistreamData? = nil
}

public struct SetMultistreamResponseV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var multistream: MultistreamV2 {
    get {return _multistream ?? MultistreamV2()}
    set {_multistream = newValue}
  }
  /// Returns true if `multistream` has been explicitly set.
  public var hasMultistream: Bool {return self._multistream != nil}
  /// Clears the value of `multistream`. Subsequent reads from it will return its default value.
  public mutating func clearMultistream() {self._multistream = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _multistream: MultistreamV2? = nil
}

public struct MultistreamV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var streamID: String = String()

  public var type: MultistreamType = .unknownType

  public var title: String = String()

  public var description_p: String = String()

  public var status: MultistreamStatus = .unknownStatus

  public var data: MultistreamData {
    get {return _data ?? MultistreamData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: MultistreamData? = nil
}

public struct MultistreamData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: MultistreamData.OneOf_Data? = nil

  public var multistreamYoutube: MultistreamYoutube {
    get {
      if case .multistreamYoutube(let v)? = data {return v}
      return MultistreamYoutube()
    }
    set {data = .multistreamYoutube(newValue)}
  }

  public var multistreamFacebook: MultistreamFacebook {
    get {
      if case .multistreamFacebook(let v)? = data {return v}
      return MultistreamFacebook()
    }
    set {data = .multistreamFacebook(newValue)}
  }

  public var multistreamInstagram: MultistreamInstagram {
    get {
      if case .multistreamInstagram(let v)? = data {return v}
      return MultistreamInstagram()
    }
    set {data = .multistreamInstagram(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable {
    case multistreamYoutube(MultistreamYoutube)
    case multistreamFacebook(MultistreamFacebook)
    case multistreamInstagram(MultistreamInstagram)

  #if !swift(>=4.1)
    public static func ==(lhs: MultistreamData.OneOf_Data, rhs: MultistreamData.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.multistreamYoutube, .multistreamYoutube): return {
        guard case .multistreamYoutube(let l) = lhs, case .multistreamYoutube(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multistreamFacebook, .multistreamFacebook): return {
        guard case .multistreamFacebook(let l) = lhs, case .multistreamFacebook(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multistreamInstagram, .multistreamInstagram): return {
        guard case .multistreamInstagram(let l) = lhs, case .multistreamInstagram(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct MultistreamYoutube {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var category: String = String()

  public var privacy: String = String()

  public var availableCategories: [String] = []

  public var availablePrivacy: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MultistreamFacebook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelType: FbChannelType = .unknownChannel

  public var channelID: String {
    get {return _channelID ?? String()}
    set {_channelID = newValue}
  }
  /// Returns true if `channelID` has been explicitly set.
  public var hasChannelID: Bool {return self._channelID != nil}
  /// Clears the value of `channelID`. Subsequent reads from it will return its default value.
  public mutating func clearChannelID() {self._channelID = nil}

  public var idToNameGroups: Dictionary<String,String> = [:]

  public var idToNamePages: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channelID: String? = nil
}

public struct MultistreamInstagram {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coverID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MultistreamTypeToToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: MultistreamType = .unknownType

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct StartStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var streamID: String = String()

  public var tokens: [MultistreamTypeToToken] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct StartStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var multistreamStatuses: [MultistreamTypeToStatus] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MultistreamTypeToStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: MultistreamType = .unknownType

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FinishStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var streamID: String = String()

  public var tokens: [MultistreamTypeToToken] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FinishStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Number of viewers attended the stream
  public var viewersCount: UInt64 = 0

  ///*
  /// Number of orders made and paid during the stream
  public var ordersCount: UInt64 = 0

  ///*
  /// Time between stream start and finish
  public var streamDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _streamDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_streamDuration = newValue}
  }
  /// Returns true if `streamDuration` has been explicitly set.
  public var hasStreamDuration: Bool {return self._streamDuration != nil}
  /// Clears the value of `streamDuration`. Subsequent reads from it will return its default value.
  public mutating func clearStreamDuration() {self._streamDuration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _streamDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

public struct GetStreamEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var streamID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct StreamStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Number of viewers attending the stream
  public var viewersCount: UInt64 = 0

  ///*
  /// Number of orders made and paid during the stream
  public var ordersCount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetStreamEventsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var event: GetStreamEventsResponse.OneOf_Event? = nil

  public var stats: StreamStats {
    get {
      if case .stats(let v)? = event {return v}
      return StreamStats()
    }
    set {event = .stats(newValue)}
  }

  public var warning: GetStreamEventsResponse.Warning {
    get {
      if case .warning(let v)? = event {return v}
      return GetStreamEventsResponse.Warning()
    }
    set {event = .warning(newValue)}
  }

  public var platformStatus: GetStreamEventsResponse.PlatformStatus {
    get {
      if case .platformStatus(let v)? = event {return v}
      return GetStreamEventsResponse.PlatformStatus()
    }
    set {event = .platformStatus(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Event: Equatable {
    case stats(StreamStats)
    case warning(GetStreamEventsResponse.Warning)
    case platformStatus(GetStreamEventsResponse.PlatformStatus)

  #if !swift(>=4.1)
    public static func ==(lhs: GetStreamEventsResponse.OneOf_Event, rhs: GetStreamEventsResponse.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stats, .stats): return {
        guard case .stats(let l) = lhs, case .stats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.warning, .warning): return {
        guard case .warning(let l) = lhs, case .warning(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.platformStatus, .platformStatus): return {
        guard case .platformStatus(let l) = lhs, case .platformStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Warning {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct PlatformStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var status: [MultistreamTypeToStatus] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct PublishMultistreamInstagramRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var streamID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PublishMultistreamInstagramResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var postURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension MultistreamType: @unchecked Sendable {}
extension MultistreamStatus: @unchecked Sendable {}
extension FbChannelType: @unchecked Sendable {}
extension GetStreamResponse: @unchecked Sendable {}
extension GetStreamResponse.LiveStatus: @unchecked Sendable {}
extension GetAvailableMultistreamsRequest: @unchecked Sendable {}
extension GetAvailableMultistreamsRequest.TypeToken: @unchecked Sendable {}
extension GetAvailableMultistreamsRequestV2: @unchecked Sendable {}
extension GetAvailableMultistreamsResponseV2: @unchecked Sendable {}
extension GetAvailableMultistreamsResponse: @unchecked Sendable {}
extension SetMultistreamRequest: @unchecked Sendable {}
extension SetMultistreamResponse: @unchecked Sendable {}
extension Multistream: @unchecked Sendable {}
extension SetMultistreamRequestV2: @unchecked Sendable {}
extension SetMultistreamResponseV2: @unchecked Sendable {}
extension MultistreamV2: @unchecked Sendable {}
extension MultistreamData: @unchecked Sendable {}
extension MultistreamData.OneOf_Data: @unchecked Sendable {}
extension MultistreamYoutube: @unchecked Sendable {}
extension MultistreamFacebook: @unchecked Sendable {}
extension MultistreamInstagram: @unchecked Sendable {}
extension MultistreamTypeToToken: @unchecked Sendable {}
extension StartStreamRequest: @unchecked Sendable {}
extension StartStreamResponse: @unchecked Sendable {}
extension MultistreamTypeToStatus: @unchecked Sendable {}
extension FinishStreamRequest: @unchecked Sendable {}
extension FinishStreamResponse: @unchecked Sendable {}
extension GetStreamEventsRequest: @unchecked Sendable {}
extension StreamStats: @unchecked Sendable {}
extension GetStreamEventsResponse: @unchecked Sendable {}
extension GetStreamEventsResponse.OneOf_Event: @unchecked Sendable {}
extension GetStreamEventsResponse.Warning: @unchecked Sendable {}
extension GetStreamEventsResponse.PlatformStatus: @unchecked Sendable {}
extension PublishMultistreamInstagramRequest: @unchecked Sendable {}
extension PublishMultistreamInstagramResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension MultistreamType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "YOUTUBE"),
    2: .same(proto: "FACEBOOK"),
    3: .same(proto: "INSTAGRAM"),
  ]
}

extension MultistreamStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_STATUS"),
    1: .same(proto: "CONNECTED"),
    2: .same(proto: "DISCONNECTED"),
    3: .same(proto: "WAITING"),
  ]
}

extension FbChannelType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_CHANNEL"),
    1: .same(proto: "PROFILE"),
    2: .same(proto: "GROUP"),
    3: .same(proto: "PAGE"),
  ]
}

extension GetStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetStreamResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "streamingUrl"),
    3: .same(proto: "plannedStart"),
    4: .same(proto: "liveStatus"),
    5: .same(proto: "actualStart"),
    6: .same(proto: "stats"),
    7: .same(proto: "actualFinish"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.streamingURL) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._plannedStart) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._liveStatus) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._actualStart) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._actualFinish) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.streamingURL.isEmpty {
      try visitor.visitSingularStringField(value: self.streamingURL, fieldNumber: 2)
    }
    try { if let v = self._plannedStart {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._liveStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._actualStart {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._actualFinish {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetStreamResponse, rhs: GetStreamResponse) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.streamingURL != rhs.streamingURL {return false}
    if lhs._plannedStart != rhs._plannedStart {return false}
    if lhs._liveStatus != rhs._liveStatus {return false}
    if lhs._actualStart != rhs._actualStart {return false}
    if lhs._stats != rhs._stats {return false}
    if lhs._actualFinish != rhs._actualFinish {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetStreamResponse.LiveStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "PLANNED"),
    2: .same(proto: "ACTIVE"),
    3: .same(proto: "FINISHED"),
    4: .same(proto: "CANCELLED"),
  ]
}

extension GetAvailableMultistreamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetAvailableMultistreamsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "streamId"),
    2: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetAvailableMultistreamsRequest, rhs: GetAvailableMultistreamsRequest) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetAvailableMultistreamsRequest.TypeToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = GetAvailableMultistreamsRequest.protoMessageName + ".TypeToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetAvailableMultistreamsRequest.TypeToken, rhs: GetAvailableMultistreamsRequest.TypeToken) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetAvailableMultistreamsRequestV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetAvailableMultistreamsRequestV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "streamId"),
    2: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetAvailableMultistreamsRequestV2, rhs: GetAvailableMultistreamsRequestV2) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetAvailableMultistreamsResponseV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetAvailableMultistreamsResponseV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "availableMultistreams"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.availableMultistreams) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.availableMultistreams.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.availableMultistreams, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetAvailableMultistreamsResponseV2, rhs: GetAvailableMultistreamsResponseV2) -> Bool {
    if lhs.availableMultistreams != rhs.availableMultistreams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetAvailableMultistreamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetAvailableMultistreamsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "availableMultistreams"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.availableMultistreams) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.availableMultistreams.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.availableMultistreams, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetAvailableMultistreamsResponse, rhs: GetAvailableMultistreamsResponse) -> Bool {
    if lhs.availableMultistreams != rhs.availableMultistreams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetMultistreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SetMultistreamRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "streamId"),
    2: .same(proto: "type"),
    3: .same(proto: "title"),
    4: .same(proto: "description"),
    5: .same(proto: "category"),
    6: .same(proto: "privacy"),
    7: .same(proto: "connect"),
    8: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.privacy) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.connect) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 5)
    }
    if !self.privacy.isEmpty {
      try visitor.visitSingularStringField(value: self.privacy, fieldNumber: 6)
    }
    if self.connect != false {
      try visitor.visitSingularBoolField(value: self.connect, fieldNumber: 7)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SetMultistreamRequest, rhs: SetMultistreamRequest) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.category != rhs.category {return false}
    if lhs.privacy != rhs.privacy {return false}
    if lhs.connect != rhs.connect {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetMultistreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SetMultistreamResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "multistream"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._multistream) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._multistream {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SetMultistreamResponse, rhs: SetMultistreamResponse) -> Bool {
    if lhs._multistream != rhs._multistream {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Multistream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Multistream"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "streamId"),
    2: .same(proto: "type"),
    3: .same(proto: "title"),
    4: .same(proto: "description"),
    5: .same(proto: "category"),
    6: .same(proto: "availableCategories"),
    7: .same(proto: "privacy"),
    8: .same(proto: "availablePrivacy"),
    9: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.availableCategories) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.privacy) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.availablePrivacy) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 5)
    }
    if !self.availableCategories.isEmpty {
      try visitor.visitRepeatedStringField(value: self.availableCategories, fieldNumber: 6)
    }
    if !self.privacy.isEmpty {
      try visitor.visitSingularStringField(value: self.privacy, fieldNumber: 7)
    }
    if !self.availablePrivacy.isEmpty {
      try visitor.visitRepeatedStringField(value: self.availablePrivacy, fieldNumber: 8)
    }
    if self.status != .unknownStatus {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Multistream, rhs: Multistream) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.category != rhs.category {return false}
    if lhs.availableCategories != rhs.availableCategories {return false}
    if lhs.privacy != rhs.privacy {return false}
    if lhs.availablePrivacy != rhs.availablePrivacy {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetMultistreamRequestV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SetMultistreamRequestV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "streamId"),
    2: .same(proto: "type"),
    3: .same(proto: "title"),
    4: .same(proto: "description"),
    5: .same(proto: "connect"),
    6: .same(proto: "token"),
    7: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.connect) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if self.connect != false {
      try visitor.visitSingularBoolField(value: self.connect, fieldNumber: 5)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 6)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SetMultistreamRequestV2, rhs: SetMultistreamRequestV2) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.connect != rhs.connect {return false}
    if lhs.token != rhs.token {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetMultistreamResponseV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SetMultistreamResponseV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "multistream"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._multistream) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._multistream {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SetMultistreamResponseV2, rhs: SetMultistreamResponseV2) -> Bool {
    if lhs._multistream != rhs._multistream {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MultistreamV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MultistreamV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "streamId"),
    2: .same(proto: "type"),
    3: .same(proto: "title"),
    4: .same(proto: "description"),
    5: .same(proto: "status"),
    6: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if self.status != .unknownStatus {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MultistreamV2, rhs: MultistreamV2) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.status != rhs.status {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MultistreamData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MultistreamData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "multistreamYoutube"),
    2: .same(proto: "multistreamFacebook"),
    3: .same(proto: "multistreamInstagram"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: MultistreamYoutube?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .multistreamYoutube(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .multistreamYoutube(v)
        }
      }()
      case 2: try {
        var v: MultistreamFacebook?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .multistreamFacebook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .multistreamFacebook(v)
        }
      }()
      case 3: try {
        var v: MultistreamInstagram?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .multistreamInstagram(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .multistreamInstagram(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.data {
    case .multistreamYoutube?: try {
      guard case .multistreamYoutube(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .multistreamFacebook?: try {
      guard case .multistreamFacebook(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .multistreamInstagram?: try {
      guard case .multistreamInstagram(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MultistreamData, rhs: MultistreamData) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MultistreamYoutube: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MultistreamYoutube"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .same(proto: "privacy"),
    3: .same(proto: "availableCategories"),
    4: .same(proto: "availablePrivacy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.privacy) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.availableCategories) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.availablePrivacy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 1)
    }
    if !self.privacy.isEmpty {
      try visitor.visitSingularStringField(value: self.privacy, fieldNumber: 2)
    }
    if !self.availableCategories.isEmpty {
      try visitor.visitRepeatedStringField(value: self.availableCategories, fieldNumber: 3)
    }
    if !self.availablePrivacy.isEmpty {
      try visitor.visitRepeatedStringField(value: self.availablePrivacy, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MultistreamYoutube, rhs: MultistreamYoutube) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.privacy != rhs.privacy {return false}
    if lhs.availableCategories != rhs.availableCategories {return false}
    if lhs.availablePrivacy != rhs.availablePrivacy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MultistreamFacebook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MultistreamFacebook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelType"),
    2: .same(proto: "channelId"),
    3: .same(proto: "idToNameGroups"),
    4: .same(proto: "idToNamePages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.channelType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._channelID) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.idToNameGroups) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.idToNamePages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.channelType != .unknownChannel {
      try visitor.visitSingularEnumField(value: self.channelType, fieldNumber: 1)
    }
    try { if let v = self._channelID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.idToNameGroups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.idToNameGroups, fieldNumber: 3)
    }
    if !self.idToNamePages.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.idToNamePages, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MultistreamFacebook, rhs: MultistreamFacebook) -> Bool {
    if lhs.channelType != rhs.channelType {return false}
    if lhs._channelID != rhs._channelID {return false}
    if lhs.idToNameGroups != rhs.idToNameGroups {return false}
    if lhs.idToNamePages != rhs.idToNamePages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MultistreamInstagram: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MultistreamInstagram"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coverId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.coverID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.coverID.isEmpty {
      try visitor.visitSingularStringField(value: self.coverID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MultistreamInstagram, rhs: MultistreamInstagram) -> Bool {
    if lhs.coverID != rhs.coverID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MultistreamTypeToToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MultistreamTypeToToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MultistreamTypeToToken, rhs: MultistreamTypeToToken) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StartStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "StartStreamRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "streamId"),
    2: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StartStreamRequest, rhs: StartStreamRequest) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StartStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "StartStreamResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "multistreamStatuses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.multistreamStatuses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.multistreamStatuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.multistreamStatuses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StartStreamResponse, rhs: StartStreamResponse) -> Bool {
    if lhs.multistreamStatuses != rhs.multistreamStatuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MultistreamTypeToStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MultistreamTypeToStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MultistreamTypeToStatus, rhs: MultistreamTypeToStatus) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FinishStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FinishStreamRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "streamId"),
    2: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FinishStreamRequest, rhs: FinishStreamRequest) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FinishStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FinishStreamResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "viewersCount"),
    2: .same(proto: "ordersCount"),
    3: .same(proto: "streamDuration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.viewersCount) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.ordersCount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._streamDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.viewersCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.viewersCount, fieldNumber: 1)
    }
    if self.ordersCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.ordersCount, fieldNumber: 2)
    }
    try { if let v = self._streamDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FinishStreamResponse, rhs: FinishStreamResponse) -> Bool {
    if lhs.viewersCount != rhs.viewersCount {return false}
    if lhs.ordersCount != rhs.ordersCount {return false}
    if lhs._streamDuration != rhs._streamDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetStreamEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetStreamEventsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "streamId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetStreamEventsRequest, rhs: GetStreamEventsRequest) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StreamStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "StreamStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "viewersCount"),
    2: .same(proto: "ordersCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.viewersCount) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.ordersCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.viewersCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.viewersCount, fieldNumber: 1)
    }
    if self.ordersCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.ordersCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StreamStats, rhs: StreamStats) -> Bool {
    if lhs.viewersCount != rhs.viewersCount {return false}
    if lhs.ordersCount != rhs.ordersCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetStreamEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetStreamEventsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stats"),
    2: .same(proto: "warning"),
    3: .same(proto: "platformStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: StreamStats?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .stats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .stats(v)
        }
      }()
      case 2: try {
        var v: GetStreamEventsResponse.Warning?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .warning(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .warning(v)
        }
      }()
      case 3: try {
        var v: GetStreamEventsResponse.PlatformStatus?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .platformStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .platformStatus(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .stats?: try {
      guard case .stats(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .warning?: try {
      guard case .warning(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .platformStatus?: try {
      guard case .platformStatus(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetStreamEventsResponse, rhs: GetStreamEventsResponse) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetStreamEventsResponse.Warning: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = GetStreamEventsResponse.protoMessageName + ".Warning"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetStreamEventsResponse.Warning, rhs: GetStreamEventsResponse.Warning) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetStreamEventsResponse.PlatformStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = GetStreamEventsResponse.protoMessageName + ".PlatformStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetStreamEventsResponse.PlatformStatus, rhs: GetStreamEventsResponse.PlatformStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PublishMultistreamInstagramRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PublishMultistreamInstagramRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "streamId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PublishMultistreamInstagramRequest, rhs: PublishMultistreamInstagramRequest) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PublishMultistreamInstagramResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PublishMultistreamInstagramResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "postUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.postURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.postURL.isEmpty {
      try visitor.visitSingularStringField(value: self.postURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PublishMultistreamInstagramResponse, rhs: PublishMultistreamInstagramResponse) -> Bool {
    if lhs.postURL != rhs.postURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
